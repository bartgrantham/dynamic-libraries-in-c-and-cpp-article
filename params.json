{"name":"Dynamic-libraries-in-c-and-cpp-article","body":"## Dynamic Libraries in C and C++ ##\r\n\r\n  I first encountered software \"plugins\" with Photoshop 3.0 and Kai's Power \r\nTools on Windows 3.1... and it blew my mind!  The idea that a piece of software \r\ncould be architected so that you could add and remove extra *3rd party* modules \r\nand have them integrate so tightly was something of a revelation to\r\nme. Separate programs communicating was one thing, but this was a seamless \r\nextension to an existing piece of software.  Amazing.\r\n\r\n  In programming this technique is known as a \"dynamic library\" and its \r\nimplementation varies by operating system, largely splitting between Windows \r\nand Unix-variant lines.  This is because it involves a great deal of \r\nbehind-the-scenes magic in order to open the library, sift through its symbol \r\ntable to find the function(s) you are looking for, and then finally invoke the \r\nnew function(s) without disrupting the operation of your program.  This process \r\nis known as 'linking' and it happens for most programs at run time as well, so \r\nit is natural that this is dependent on the operating system's understanding of \r\nlibraries and how a running process is constructed.\r\n\r\n  I'm going to show how this process works in C and C++, providing simple \r\nexamples along the way.  Putting together sophisticated user interfaces that \r\nexploit these techniques is beyond the scope here, I want to just show the \r\nbasics and leave the menus, etc. up to you.  My examples are for *nix systems \r\nand I'm going to assume proficiency in C and C++.\r\n\r\n\r\n----\r\n\r\n### Dynamic Libraries in C ###\r\n\r\n  The conceptual problem is this: from inside of a running program, how do I \r\nfind a function in a compiled file and then how do I execute it?\r\n\r\n  The second part of that question is easily answered by the language\r\nitself.  C and C++ provide a data type of \"function pointer\" that can be used \r\nsyntactically in the same places that a function can, but can have an \r\nassignable value.  Declaring a function pointer looks like `void \r\n(*my_func_ptr)();` and you can call it just like any other function with \r\n`my_func_ptr();`.  This declares a function, `my_func_ptr`, that accepts no \r\narguments and returns nothing.  If necessary, you can declare an argument list \r\nand return type, such as `int (*my_func_ptr)(char *, const int);` .  In this \r\ncase, `my_func_ptr()` takes a pointer to char and an int and returns an int \r\n(for example, for counting the number of vowels in the first n characters in a \r\nstring and returning that value).\r\n\r\n   It's important to point out that C/C++ can only resolve this data typing at \r\ncompile time.  Since type information is not baked into compiled objects, there \r\nis no way for the program to determine at run time if the function has the \r\ncorrect signature.  With dynamic libraries this is entirely up to you to make \r\nsure that you're invoking the dynamically loaded functions with the correct \r\narguments and working with their output properly.  This is why it's typical to \r\nput function signatures in `.h` files so that there is a published standard for \r\ninterconnecting modules to conform to and the compiler can help sanity check \r\nthe comings and goings of your function calls.\r\n\r\n  So if we can get the address of a function in a compiled file, we can use \r\nassign it to a function pointer.  How do we get the address of a function in a \r\ncompiled file, though?  In Unix systems this is provided by the functions \r\n`dlopen()` and `dlsym()` (there are also `dlclose()` and `dlerror()`, which \r\nI'll leave for you to read the man pages of).  `dlopen()` takes two arguments, \r\na file path and a set of flags that indicate how the system should manage  the \r\ncontents of the library, and it returns a handle to the library.  `dlsym()` \r\ntakes the library handle that `dlopen()` provided and a string for a symbol \r\n(such as the name of a function), and returns... a function pointer! (or \r\nwhatever datatype that symbol references)  Now we have the mechanisms to see \r\nhow this works in code, disregarding error checking:\r\n\r\n    #include <dlfcn.h>\r\n\r\n    void * library_handle;\r\n    void (* my_dyn_func)();\r\n    library_handle = dlopen(\"mylibrary.so\", 0);  // 0 == default flags == RTLD_GLOBAL | RTLD_LAZY\r\n    my_dyn_func = dlsym(library_handle, \"plugin_func_name\");\r\n    my_dyn_func();\r\n\r\n   This isn't the whole story, though.  In order for `dlopen()` and `dlsym()` \r\nto be able to read and understand the library (\"mylibrary.so\" in the example), \r\nyou'll need to compile it with special flags to indicate that you want the \r\ncompiler to preserve the symbol table and format it so that the loader can read \r\nit properly.  With gcc this flag is \"-shared\", which stands for \"shared \r\nobject\".  This is where the .so filename extension comes from as well.  *Note \r\nthat this is not an \"object\" in the sense of object-oriented programming.*  \r\nIt's just a generic use of the term to indicate a binary file that contains a \r\nset of related functions and data.\r\n\r\nSo that's it.  Here's the bare minimum:\r\n\r\n  * compile your function into a dynamic library (aka shared object) with \"-shared\"\r\n  * open the library with `dlopen()` and find the function with `dlsym()`\r\n  * assign the value to a function pointer\r\n\r\nThere is a very simple example in the `dlopen_c_example` directory.  It \r\nincludes two library files (testlib1.c, testlib2.c), an application that can \r\nuse either library based on its command line arguments (dlopen.c), and a \r\nMakefile.  You can compile with:\r\n\r\n    # make\r\n\r\nAnd try it out with:\r\n\r\n    # ./dlopen testlib1.so test\r\n\r\n  You can use \"testlib1.so\" or \"testlib2.so\" for the first argument or \"testa\" \r\nor \"testb\" for the second.  This illustrates not just dynamic loading of \r\ndifferent code at run time, but also running of different functions.  I've also \r\nincluded finding a string that is the name of the library for the user's \r\nbenefit.  Try out all the combinations at once with:\r\n\r\n    # make test\r\n\r\n\r\n----\r\n\r\n### Dynamic Libraries in C++ ###\r\n\r\n  For C we simply wanted to execute a dynamically loaded function.  Naturally \r\nin C++ we want to work with objects, ideally instantiating an object from a \r\ndynamically loaded class.\r\n\r\n  Now that we've covered how the mechanisms work in C, certainly C++ has a more \r\nsophisticated OO paradigm for dynamically loading code, right?  Unfortunately, \r\nthat's not the case.  We still use `dlopen()` and `dlsym()`, but because of the \r\nway C++ mangles method names it is difficult or impossible to acquire the \r\naddress of an object's constructor on the fly.  This makes creating objects \r\nfrom dynamic libraries much more difficult.\r\n\r\n<!---\r\nTODO: Exposition on how it would be nice to have it work, including a reference \r\nto RTTI\r\n-->\r\n\r\n  One technique for managing this is to have a _statically defined_ object in \r\nthe dynamic library that acts as a factory for creating the object we have in \r\nmind.  If we create a standard interface for this factory and a generic \r\nsuperclass for the object we want to create, we can subclass both while while \r\nstill allowing the calling program to find the object and create the dynamic \r\nobject.  It sounds complicated... and it is!  If we examine the technique one \r\nstep at a time while looking at the necessity of each mechanism it should make \r\nthe process clear.\r\n\r\n<!---\r\nTODO: Sidebar on how to use a less sophisticated version with extern C and the \r\nuse of new\r\n-->\r\n\r\n  We start by understanding the need and design of our factory class and why an \r\nobject of this factory class needs to be instantiated statically in the \r\ncompiled library, instead of dynamically at runtime in the code as you may be \r\nmore familiar with.\r\n\r\n  In order to handle multiple methods with the same name but differing \r\nparameter types, as well as namespaces, C++ compilers will perform \"name \r\nmangling\" on the symbols that are stored in compiled object code.  This name \r\nmangling is not standardized, and it can even vary between different versions \r\nof the same compiler!  (There is an excellent example on Wikipedia in the \r\n[article on name mangling]).  Because of this name mangling it is impossible to \r\nreach inside a shared object and pull out the address of an class constructor, \r\neven if you know the name of the class.  For example, the constructor for a \r\n\"Foo\" object has the name \"__ZN3fooC1Ev\" in the symbol table on my laptop (GCC \r\n4.2.1 on MacOS 10.6).\r\n\r\n  [article on name mangling]: http://en.wikipedia.org/wiki/Name_mangling#Complex_example\r\n\r\n  So if all method names including constructors are unknown, how can we make \r\nuse of a C++ dynamic library?  One solution, and the one I'll demonstrate, is \r\nto have a _statically allocated_ factory object in the library that inherits \r\nfrom a common factory class.  This common factory class contains a virtual \r\nmethod that we override with our own method that we'll call at run-time to \r\ncreate the dynamic object we ultimately want.  What this means in code is that \r\nwe declare an instance object of this factory class in file scope (outside of \r\nany methods/functions) so we are declaring it as `static`.  This has two \r\nresults: the dynamic library will be arranged so when `dlopen()` opens the \r\nlibrary the constructor of this factory object is called, and most importantly \r\n_that the name of the instantiated factory object is not mangled_.  This gives \r\nus a known anchor into the dynamic library for code that we can use to do \r\nmore... such as creating other objects!\r\n\r\n  The use of a factory may seem a roundabout technique for being able to \r\ndynamically load in a new object, but as we walk through the example you may be \r\ninspired and see ways in which this technique provides a great deal of \r\nflexibility for managing dynamic objects of unknown class.  For the example, \r\nthe objects that we want to create dynamically at runtime are descended from a \r\nbase class, `plugin`.  The interface to `plugin` is defined as:\r\n\r\n    class plugin\r\n    {\r\n        public:\r\n            // default constructor\r\n            virtual void test() { };\r\n            virtual ~plugin() {};\r\n    };\r\n\r\n  Pretty straightforward.  We rely on the compiler to create the default \r\nconstructor, and `test()` will be the function that we override in our plugins \r\nthat performs expanded functionality.  The destructor is marked `virtual` \r\nbecause we expect full-featured plugins will have their own unloading \r\nrequirements (removing menu entries, closing files or sockets, etc.)  However, \r\nfor the example the plugins will have very simple destructors.\r\n\r\n  Now we can look at the `factory` class.  Remember that the purpose of the \r\nfactory is to have a known function entry point in the library that we can find \r\nand use to create our objects.  The factory can be made as complex as needed, \r\nbut at its simplest it only provides a virtual function that returns an \r\ninstance of \"plugin\", so its interface consists of a single virtual method:\r\n\r\n    class factory\r\n    {\r\n        public:\r\n            // default constructor\r\n            virtual plugin * makedyn() { };\r\n            // default destructor\r\n    };\r\n\r\n  We can now examine the code for a dynamic library that uses and extends these \r\nbase classes.  In it are defined two classes: the plugin class that our program \r\nwill use and a factory that knows how to create this plugin. Also included in \r\nthe file is a string that provides a name for the plugin and the statically \r\ndeclared instance of the plugin factory that we'll use to create a new instance \r\nof the plugin.  Here's the code for the `foo` plugin:\r\n\r\n    const char * classname = \"foo Object\";  // name for this plugin, useful for user feedback\r\n\r\n    // the actual plugin class\r\n    class foo : public plugin\r\n    {\r\n        public:\r\n            foo()  {  cout << \"    foo created [foo.cc - foo::foo()]\" << endl;  };\r\n            ~foo() {  cout << \"    foo destroyed [foo.cc - foo::~foo()]\" << endl;  };\r\n            virtual void test() {  cout << \"    foo tested [foo.cc - foo::test()]\" << endl;  };\r\n    };\r\n\r\n\r\n    // the class of the plugin factory\r\n    class foofactory : factory\r\n    {\r\n        public:\r\n            foo * makedyn() {  cout << \"    making foo [foo.cc foofactory::makedyn()]\" << endl;  return new foo;  }\r\n    };\r\n\r\n\r\n    // a statically declared instance of our derived factory class\r\n    foofactory Factory;\r\n\r\n\r\n  Observe how the `foofactory` class overrides the `makedyn()` function to \r\ncreate and return a pointer to an object of class `foo`.  Also note the \r\n`foofactory` instance named `Factory`, declared at the bottom of the code \r\nsnippet.  Finally, see that the foo class overrides the constructor, destructor \r\nand `test()` methods of the `plugin` parent class.\r\n\r\n  Finally, let's examine how a program can make use of this plugin.  In the C \r\nexample we declared a function pointer and then assigned to it the value of a \r\nfunction address once we had looked it up in the dynamic library, like this:\r\n\r\n    void (* my_dyn_func)();\r\n    library_handle = dlopen(\"mylibrary.so\", 0);\r\n    my_dyn_func = dlsym(library_handle, \"plugin_func_name\");\r\n    my_dyn_func();\r\n\r\n  Since this is C++ and we're working with objects, instead of a function \r\npointer we'll use pointers to objects to hold both the dynamic library's \"entry \r\npoint\" as well as the plugin that contains the dynamic code we're loading.  Now \r\nwe can reveal the actual `dlopen()`, `dlsym()`, and factory method that loads \r\nour dynamic plugin class:\r\n\r\n    #include <dlfcn.h>\r\n\r\n    void * library_handle;\r\n    factory * myFactory;\r\n    plugin * myPlugin;\r\n\r\n    library_handle = dlopen(\"mylibrary.so\", 0);\r\n\r\n    myFactory = (factory *)dlsym(handle, \"Factory\");  // find the statically declared factory\r\n    myPlugin = myFactory->makedyn();                  // create our dynamic plugin\r\n    myPlugin->test();                                 // call our plugin-specific code\r\n\r\n  The critical point in this code is the string \"Factory\" that `dlsym()` uses \r\nto find the statically defined factory class.  Like \"plugin_func_name\" in the C \r\nexample, there must be a variable with a known symbol name that `dlsym()` can \r\nfind.  Once the address of this symbol is found and cast to a `factory` class \r\nwe can use its overriden virtual method `makedyn()` to create a plugin object.  \r\nThen we can call the overriden virtual method `test()` of the plugin object to \r\ncall plugin-specific code.\r\n\r\n  And, like the C example, the plugin must be compiled with the \"-shared\" flag \r\nso that the object file includes the symbol table that allows it to be parsed \r\nand then found by the `dlopen()` and `dlsym()` functions.  On most operating \r\nsystems (but not MacOSX) an additional flag may need to be passed as well, \r\n\"-fPIC\".  PIC stands for \"position independent code\" and it means that the \r\nresulting object code is structured so that function calls aren't hardwired to \r\nspecific locations in memory, a requirement for code that may be loaded \r\nanywhere and in any order at run-time.  A thorough explanation of PIC is \r\noutside the scope of this article but generally this means that the resulting \r\nassembly code uses relative addressing in function calls, rather than absolute \r\naddresses. Wikipedia has a [good article on PIC].\r\n\r\n  [good article on PIC]: http://en.wikipedia.org/wiki/Position-independent_code\r\n\r\n  That wraps up the C++ dynamic code example.  Here's the bare minimum for this \r\ntechnique:\r\n\r\n  * two base classes: the plugin itself with virtual methods to be overridden \r\nin derived classes for custom functionality, and a factory with a single \r\nvirtual method to be overridden by a plugin's corresponding derived factory \r\nclass\r\n  * plugin code that extends these two base classes, with a statically declared \r\ninstance of the derived factory in the plugin library\r\n  * compile your plugin code into a dynamic library (aka shared object) with \r\n\"-shared\" and \"-fPIC\"\r\n  * open the library with dlopen and find the factory instance with dlsym\r\n  * use the factory's virtual method to create a new plugin object\r\n\r\nThere is an example in the `dlopen_cpp_example` directory.  It includes three \r\nplugins (foo.cc, bar.cc, and baz.cc), an application that can dynamically load \r\na library based on command line arguments (dlopen.cc), headers, and a Makefile.  \r\nYou can compile with:\r\n\r\n    # make\r\n\r\nAnd try it out with\r\n\r\n    # ./dlopen foo.so\r\n\r\n  You can substitute foo.so with bar.so or baz.so and the code will load up the \r\nbar and baz plugins appropriately.  Try all the combinations at once with:\r\n\r\n    # make test\r\n\r\nHave fun!  And if you have any questions, please feel free to comment below or \r\n[drop me a line].\r\n\r\n  [drop me a line]: http://www.bartgrantham.com/contact/\r\n","tagline":"Dynamic Libraries in C and C++ Article","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}